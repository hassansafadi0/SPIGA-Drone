<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ZoneOperation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">spiga-simulator</a> &gt; <a href="index.source.html" class="el_package">com.spiga.env</a> &gt; <span class="el_source">ZoneOperation.java</span></div><h1>ZoneOperation.java</h1><pre class="source lang-java linenums">package com.spiga.env;

import com.spiga.core.Point3D;
import java.util.ArrayList;
import java.util.List;

/**
 * Represents the operational zone of the simulation.
 * Manages environmental factors (wind, precipitation, currents), obstacles, and
 * collision detection.
 */
public class ZoneOperation {
    private Point3D minCoord;
    private Point3D maxCoord;
    private Point3D vent; // Direction and intensity
    private double precipitations; // Intensity
    private Point3D courantMarin; // 3D vector
    private List&lt;Obstacle&gt; obstacles;
    private List&lt;Island&gt; islands;
    private static final int GRID_SIZE = 50; // 50x50 grid for 1000x1000 world (20 units per cell)

    private List&lt;Collidable&gt; collidables;

<span class="fc" id="L24">    public ZoneOperation(Point3D minCoord, Point3D maxCoord) {</span>
<span class="fc" id="L25">        this.minCoord = minCoord;</span>
<span class="fc" id="L26">        this.maxCoord = maxCoord;</span>
<span class="fc" id="L27">        this.vent = new Point3D(0, 0, 0);</span>
<span class="fc" id="L28">        this.precipitations = 0;</span>
<span class="fc" id="L29">        this.courantMarin = new Point3D(0, 0, 0);</span>
<span class="fc" id="L30">        this.obstacles = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L31">        this.islands = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L32">        this.collidables = new ArrayList&lt;&gt;();</span>

        // Define Islands
        // Island 1: Circle at (300, 300), Radius 150
<span class="fc" id="L36">        islands.add(new Island(300, 300, 150, 150, true));</span>
        // Island 2: Rectangle at (700, 700), 200x300
<span class="fc" id="L38">        islands.add(new Island(700, 700, 200, 300, false));</span>
<span class="fc" id="L39">    }</span>

    /**
     * Nested class representing an island obstacle.
     */
    public static class Island {
        /** X coordinate of the island center/top-left. */
        private double x;
        /** Y coordinate of the island center/top-left. */
        private double y;
        /** Width or radius of the island. */
        private double w;
        /** Height of the island (if not circular). */
        private double h;
        /** True if the island is circular, false if rectangular. */
        private boolean isCircle;

        /**
         * Constructor for Island.
         * 
         * @param x        X coordinate.
         * @param y        Y coordinate.
         * @param w        Width or radius.
         * @param h        Height.
         * @param isCircle Shape type.
         */
<span class="fc" id="L65">        public Island(double x, double y, double w, double h, boolean isCircle) {</span>
<span class="fc" id="L66">            this.x = x;</span>
<span class="fc" id="L67">            this.y = y;</span>
<span class="fc" id="L68">            this.w = w;</span>
<span class="fc" id="L69">            this.h = h;</span>
<span class="fc" id="L70">            this.isCircle = isCircle;</span>
<span class="fc" id="L71">        }</span>

        public double getX() {
<span class="nc" id="L74">            return x;</span>
        }

        public double getY() {
<span class="nc" id="L78">            return y;</span>
        }

        public double getW() {
<span class="nc" id="L82">            return w;</span>
        }

        public double getH() {
<span class="nc" id="L86">            return h;</span>
        }

        public boolean isCircle() {
<span class="nc" id="L90">            return isCircle;</span>
        }

        public boolean contains(double px, double py) {
<span class="fc bfc" id="L94" title="All 2 branches covered.">            if (isCircle) {</span>
<span class="fc bfc" id="L95" title="All 2 branches covered.">                return Math.sqrt(Math.pow(px - x, 2) + Math.pow(py - y, 2)) &lt;= w;</span>
            } else {
                // Rectangle centered at x,y
<span class="fc bfc" id="L98" title="All 8 branches covered.">                return px &gt;= x - w / 2 &amp;&amp; px &lt;= x + w / 2 &amp;&amp; py &gt;= y - h / 2 &amp;&amp; py &lt;= y + h / 2;</span>
            }
        }
    }

    /**
     * Gets the list of islands in the zone.
     * 
     * @return List of islands.
     */
    public List&lt;Island&gt; getIslands() {
<span class="nc" id="L109">        return islands;</span>
    }

    public boolean isLand(Point3D p) {
<span class="fc bfc" id="L113" title="All 2 branches covered.">        for (Island island : islands) {</span>
<span class="fc bfc" id="L114" title="All 2 branches covered.">            if (island.contains(p.getX(), p.getY()))</span>
<span class="fc" id="L115">                return true;</span>
<span class="fc" id="L116">        }</span>
<span class="fc" id="L117">        return false;</span>
    }

    public Point3D getVent() {
<span class="fc" id="L121">        return vent;</span>
    }

    public void setVent(Point3D vent) {
<span class="nc" id="L125">        this.vent = vent;</span>
<span class="nc" id="L126">    }</span>

    public double getPrecipitations() {
<span class="fc" id="L129">        return precipitations;</span>
    }

    public void setPrecipitations(double precipitations) {
<span class="nc" id="L133">        this.precipitations = precipitations;</span>
<span class="nc" id="L134">    }</span>

    public Point3D getCourantMarin() {
<span class="fc" id="L137">        return courantMarin;</span>
    }

    public void setCourantMarin(Point3D courantMarin) {
<span class="nc" id="L141">        this.courantMarin = courantMarin;</span>
<span class="nc" id="L142">    }</span>

    public void addObstacle(Obstacle obstacle) {
<span class="fc" id="L145">        this.obstacles.add(obstacle);</span>
<span class="fc" id="L146">    }</span>

    /**
     * Adds a collidable object to the zone.
     * 
     * @param c The collidable object.
     */
    public void addCollidable(Collidable c) {
<span class="fc" id="L154">        this.collidables.add(c);</span>
<span class="fc" id="L155">    }</span>

    /**
     * Removes a collidable object from the zone.
     * 
     * @param c The collidable object to remove.
     */
    public void removeCollidable(Collidable c) {
<span class="nc" id="L163">        this.collidables.remove(c);</span>
<span class="nc" id="L164">    }</span>

    /**
     * Checks if a point collides with any obstacle or collidable object.
     * 
     * @param point The point to check.
     * @return True if a collision is detected, false otherwise.
     */
    public boolean isCollision(Point3D point) {
<span class="fc" id="L173">        return isCollision(point, null);</span>
    }

    /**
     * Checks if a point collides with any obstacle or collidable object, ignoring a
     * specific object.
     * 
     * @param point    The point to check.
     * @param ignoreMe The collidable object to ignore (usually self).
     * @return True if a collision is detected, false otherwise.
     */
    public boolean isCollision(Point3D point, Collidable ignoreMe) {
        // Check static obstacles
<span class="fc bfc" id="L186" title="All 2 branches covered.">        for (Obstacle obs : obstacles) {</span>
<span class="fc bfc" id="L187" title="All 2 branches covered.">            if (obs.contains(point)) {</span>
<span class="fc" id="L188">                return true;</span>
            }
<span class="fc" id="L190">        }</span>

        // Check dynamic collidables (vehicles)
<span class="fc bfc" id="L193" title="All 2 branches covered.">        for (Collidable c : collidables) {</span>
<span class="fc bfc" id="L194" title="All 2 branches covered.">            if (c == ignoreMe)</span>
<span class="fc" id="L195">                continue;</span>

            // Check if at same Z level (with small tolerance)
<span class="fc bfc" id="L198" title="All 2 branches covered.">            if (Math.abs(c.getPosition().getZ() - point.getZ()) &lt; 0.1) {</span>
<span class="fc" id="L199">                double dist = Math.sqrt(</span>
<span class="fc" id="L200">                        Math.pow(c.getPosition().getX() - point.getX(), 2) +</span>
<span class="fc" id="L201">                                Math.pow(c.getPosition().getY() - point.getY(), 2));</span>

                // Assume default radius for the point being checked if not provided
<span class="pc bpc" id="L204" title="1 of 2 branches missed.">                double myRadius = (ignoreMe != null) ? ignoreMe.getRadius() : 5.0;</span>

<span class="pc bpc" id="L206" title="1 of 2 branches missed.">                if (dist &lt; (c.getRadius() + myRadius)) {</span>
<span class="fc" id="L207">                    return true;</span>
                }
            }
<span class="fc" id="L210">        }</span>
<span class="fc" id="L211">        return false;</span>
    }

    /**
     * Checks if a point is inside the zone boundaries.
     * 
     * @param point The point to check.
     * @return True if inside, false otherwise.
     */
    public boolean isInside(Point3D point) {
<span class="pc bpc" id="L221" title="2 of 4 branches missed.">        return point.getX() &gt;= minCoord.getX() &amp;&amp; point.getX() &lt;= maxCoord.getX() &amp;&amp;</span>
<span class="pc bpc" id="L222" title="2 of 4 branches missed.">                point.getY() &gt;= minCoord.getY() &amp;&amp; point.getY() &lt;= maxCoord.getY() &amp;&amp;</span>
<span class="pc bpc" id="L223" title="2 of 4 branches missed.">                point.getZ() &gt;= minCoord.getZ() &amp;&amp; point.getZ() &lt;= maxCoord.getZ();</span>
    }

    // A* Pathfinding
    /**
     * Finds a path from start to end using A* algorithm.
     * 
     * @param start    Starting point.
     * @param end      Ending point.
     * @param isMarine True if the vehicle is marine (avoids land), false if land
     *                 vehicle (avoids water).
     * @return A list of points representing the path.
     */
    public List&lt;Point3D&gt; findPath(Point3D start, Point3D end, boolean isMarine) {
        // Simple grid-based A*
<span class="fc" id="L238">        Node startNode = new Node((int) (start.getX() / 20), (int) (start.getY() / 20));</span>
<span class="fc" id="L239">        Node endNode = new Node((int) (end.getX() / 20), (int) (end.getY() / 20));</span>

<span class="fc" id="L241">        java.util.PriorityQueue&lt;Node&gt; openSet = new java.util.PriorityQueue&lt;&gt;(</span>
<span class="fc" id="L242">                java.util.Comparator.comparingDouble(n -&gt; n.f));</span>
<span class="fc" id="L243">        java.util.Set&lt;String&gt; closedSet = new java.util.HashSet&lt;&gt;();</span>
<span class="fc" id="L244">        java.util.Map&lt;String, Node&gt; allNodes = new java.util.HashMap&lt;&gt;();</span>

<span class="fc" id="L246">        startNode.g = 0;</span>
<span class="fc" id="L247">        startNode.h = heuristic(startNode, endNode);</span>
<span class="fc" id="L248">        startNode.f = startNode.g + startNode.h;</span>
<span class="fc" id="L249">        openSet.add(startNode);</span>
<span class="fc" id="L250">        allNodes.put(startNode.key(), startNode);</span>

<span class="fc bfc" id="L252" title="All 2 branches covered.">        while (!openSet.isEmpty()) {</span>
<span class="fc" id="L253">            Node current = openSet.poll();</span>
<span class="fc bfc" id="L254" title="All 2 branches covered.">            if (current.key().equals(endNode.key())) {</span>
<span class="fc" id="L255">                return reconstructPath(current);</span>
            }

<span class="fc" id="L258">            closedSet.add(current.key());</span>

<span class="fc bfc" id="L260" title="All 2 branches covered.">            for (Node neighbor : getNeighbors(current)) {</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">                if (closedSet.contains(neighbor.key()))</span>
<span class="fc" id="L262">                    continue;</span>

                // Check terrain constraints
<span class="fc" id="L265">                Point3D p = new Point3D(neighbor.x * 20 + 10, neighbor.y * 20 + 10, 0);</span>
<span class="fc" id="L266">                boolean land = isLand(p);</span>
<span class="fc bfc" id="L267" title="All 4 branches covered.">                if (isMarine &amp;&amp; land)</span>
<span class="fc" id="L268">                    continue; // Marine cannot go on land</span>
<span class="fc bfc" id="L269" title="All 4 branches covered.">                if (!isMarine &amp;&amp; !land)</span>
<span class="fc" id="L270">                    continue; // Land vehicle cannot go on water (assuming isMarine=false means Land vehicle)</span>
                // Note: Aerial vehicles shouldn't use this pathfinder or should have
                // isMarine=null logic?
                // For now, let's assume this method is only called for Surface/Land vehicles.

<span class="fc" id="L275">                double tentativeG = current.g + 1; // Cost 1 per step</span>

<span class="fc" id="L277">                Node existing = allNodes.get(neighbor.key());</span>
<span class="pc bpc" id="L278" title="1 of 4 branches missed.">                if (existing == null || tentativeG &lt; existing.g) {</span>
<span class="fc" id="L279">                    neighbor.parent = current;</span>
<span class="fc" id="L280">                    neighbor.g = tentativeG;</span>
<span class="fc" id="L281">                    neighbor.h = heuristic(neighbor, endNode);</span>
<span class="fc" id="L282">                    neighbor.f = neighbor.g + neighbor.h;</span>

<span class="pc bpc" id="L284" title="1 of 2 branches missed.">                    if (existing == null) {</span>
<span class="fc" id="L285">                        allNodes.put(neighbor.key(), neighbor);</span>
<span class="fc" id="L286">                        openSet.add(neighbor);</span>
                    } else {
                        // Update existing (re-add to sort)
<span class="nc" id="L289">                        openSet.remove(existing);</span>
<span class="nc" id="L290">                        existing.g = neighbor.g;</span>
<span class="nc" id="L291">                        existing.f = neighbor.f;</span>
<span class="nc" id="L292">                        existing.parent = current;</span>
<span class="nc" id="L293">                        openSet.add(existing);</span>
                    }
                }
<span class="fc" id="L296">            }</span>
<span class="fc" id="L297">        }</span>

        // No path found, return direct line (fallback)
<span class="fc" id="L300">        List&lt;Point3D&gt; fallback = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L301">        fallback.add(end);</span>
<span class="fc" id="L302">        return fallback;</span>
    }

    private double heuristic(Node a, Node b) {
<span class="fc" id="L306">        return Math.sqrt(Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2));</span>
    }

    private List&lt;Node&gt; getNeighbors(Node n) {
<span class="fc" id="L310">        List&lt;Node&gt; neighbors = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L311">        int[] dx = { 0, 0, 1, -1, 1, 1, -1, -1 };</span>
<span class="fc" id="L312">        int[] dy = { 1, -1, 0, 0, 1, -1, 1, -1 };</span>

<span class="fc bfc" id="L314" title="All 2 branches covered.">        for (int i = 0; i &lt; 8; i++) {</span>
<span class="fc" id="L315">            int nx = n.x + dx[i];</span>
<span class="fc" id="L316">            int ny = n.y + dy[i];</span>
<span class="fc bfc" id="L317" title="All 8 branches covered.">            if (nx &gt;= 0 &amp;&amp; nx &lt; GRID_SIZE &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; GRID_SIZE) { // Use GRID_SIZE here</span>
<span class="fc" id="L318">                neighbors.add(new Node(nx, ny));</span>
            }
        }
<span class="fc" id="L321">        return neighbors;</span>
    }

    private List&lt;Point3D&gt; reconstructPath(Node current) {
<span class="fc" id="L325">        List&lt;Point3D&gt; path = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L326" title="All 2 branches covered.">        while (current != null) {</span>
<span class="fc" id="L327">            path.add(0, new Point3D(current.x * 20 + 10, current.y * 20 + 10, 0));</span>
<span class="fc" id="L328">            current = current.parent;</span>
        }
<span class="fc" id="L330">        return path;</span>
    }

    private static class Node {
        int x, y;
        double g, h, f;
        Node parent;

<span class="fc" id="L338">        public Node(int x, int y) {</span>
<span class="fc" id="L339">            this.x = x;</span>
<span class="fc" id="L340">            this.y = y;</span>
<span class="fc" id="L341">        }</span>

        public String key() {
<span class="fc" id="L344">            return x + &quot;,&quot; + y;</span>
        }
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.10.202304240956</span></div></body></html>